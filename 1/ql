QL(1): clive shell
.LP
.br
\l'5i'
.br
.LP
.SH
USAGE
.LP
.LP
\fC
.DS L

    usage: ql [-DLNYcinux] [file] ...
        -D: debug
        -L: debug lex
        -N: debug nodes
        -Y: debug yacc
        -c: run args as a command
        -i: interactive
        -n: dry run
        -u: do not use unix IO
        -x: print commands as they are run
    
.DE
\fR
.LP
.LP
.SH
DESCRIPTION
.LP
\fI Ql\fR is the Clive shell. In reads commands from either the standard
input or a file given in the command line and executes them. Flag\fC -c\fR
may be used to make the arguments represent a command to be executed and
not file names.
.LP
When executing a file, the entire file is read before processing its contents.
It is safe to edit or remove the file while it runs. Arguments following
the given file name are used as arguments for the script file being executed.
Under flag\fC -c\fR the command is supplied in the argument list.
.LP
Text enclosed in single or reverse quotes, like\fC '...'\fR and\fC `....`\fR
is taken verbatim as a single word.
.LP
The\fC #\fR character can be used to write line comments. Empty lines are
ignored. All other text is parsed as a series of commands. Each command
is executed only after its source text has been fully parsed. For example,
commands within a block are not executed until the entire block is read
from the input text and parses correctly.
.LP
The prompt is '\fC>\fR '. Any run of '\fC>\fR' characters (and blanks)
at the start of line are silently discarded, to help the user in selecting
command lines and executing them again.
.LP
Commands are one or more words (none for the empty command) terminated
either by a new-line character or using a '\fC;\fR'. A backslash before
a new-line converts the new-line into a space, to type long commands in
multiple lines. After a pipe-line character, a new-line may be typed and
it will be ignored, for the same purpose.
.LP
Command words are separated by runs of white space, unless they result
from constructs (described later) which preserve words as generated by
other commands.
.LP
A command can be:
.IP \(bu
A pipe line
.IP \(bu
A block of commands
.IP \(bu
A source command
.IP \(bu
A function definition, terminated with a new-line or a\fC ;\fR character.
.IP \(bu
A\fC for\fR loop
.IP \(bu
A\fC while\fR loop
.IP \(bu
A\fC cond\fR (conditional) structure
.IP \(bu
An assignment.
.LP
.LP
.LP
.LP
.LP
.LP
.LP
.LP
In all cases, optional redirections for input and output can follow. An
optional\fC &\fR can be added at the end if\fI ql\fR should not wait for
the command to terminate before prompting for another command. This is
called a background command. The\fC &\fR operator can be followed by a
name to tag the command. The\fC wait\fR builtin waits for background commands
and can be given tags as arguments to wait just for those commands. Without
arguments,\fC wait\fR waits for all outstanding background commands.
.LP
A pipe-line is a series of simple commands separated by '\fC\fR' characters,
perhaps a single one, or an empty one. Here, the\fI in\fR channel of a
command is the\fI out\fR channel of the preceding one. The syntax '\fC|[err]\fR',
(where\fI err\fR can be any channel name) connects the\fI err\fR channel
of the preceding command to the\fI in\fR channel of the following one.
The syntax '\fC|[x:y]\fR' connects the\fI y\fR channel of the preceding
command to the\fI x\fR channel of the following one. The general syntax
permits arbitrary networks of channels and has the form '\fC|[x:y,z;p:q,r...]\fR'
.LP
The first name is a list of names used as a command is understood as the
command name. If it matches the name of a function, the function is executed
as a command. If it matches the name of a built-in, the built-in is executed
as a command. If the name starts with '\fC/\fR', '\fC./\fR', or '\fC../\fR',
it is uses as a relative path to the file for the command. Otherwise, the
name is appended to each of the directories in\fC $path\fR (or\fC $PATH\fR
if the former is not defined) and the first file found with execute permissions
is run as a command. The\fC type\fR builtin may be given one or more names
and prints the type of name (function, builtin, etc.).
.LP
When a command terminates,\fC $sts\fR contains the exit status for the
command, which is empty for success.
.LP
A block of commands is a series of commands encondes in '\fC{\fR' and '\fC}\fR'
characters.
.LP
A source command has the form
.LP
\fC
.DS L

    < file
    
.DE
\fR
.LP
and executes the text in\fC file\fR as commands. This can be used to include
input for the shell from another file.
.LP
Functions may be defined line in
.LP
\fC
.DS L

    func name { cmds }
    
.DE
\fR
.LP
Once defined, the function\fI name\fR may be used as a command. Arguments
supplied are available in\fC $argv\fR within the function. The name of
the function is in\fC $argv0\fR. The status of the last command in the
function is used as the status of the function.
.LP
The\fC for\fR control structure has the form
.LP
\fC
.DS L

    for name val... { cmds }
    
.DE
\fR
.LP
and sets\fC $name\fR to each one of the names that follow and runs the
body block for each value.
.LP
When using the form
.LP
\fC
.DS L

    for name { cmds }
    
.DE
\fR
.LP
the loop iterates over the messages received from the standard input and
not over the names given in the command line.
.LP
The\fC while\fR control structure has the form
.LP
\fC
.DS L

    while cmd { cmds }
    
.DE
\fR
.LP
and executes the body block while the command used as a condition terminates
with success.
.LP
The\fC cond\fR control structure is the only conditional and has the form
.LP
\fC
.DS L

    cond {
        cmd1
        cmd2
        ...
        cmdn
    }
    
.DE
\fR
.LP
With optional\fI or\fR branches added, like in:
.LP
\fC
.DS L

    cond {
        ...
    } or {
        ...
    } or {
        ...
    } ...
    
.DE
\fR
.LP
Each one of the\fI or\fR branches (perhaps a single one if no\fI or\fR
is used) executes in order until one succeeds. An\fI or\fR branch executes
the commands in its block in order until one fails or until the last command
runs. If the last command runs, the\fI or\fR branch succeeds. In short,
the conditional is an\fI or\fR for\fI ands\fR of commands. You might think
of all commands in a block as the conditions for the last command in that
block, which might be considered as the body of a conventional\fI if\fR
construct.
.LP
.SH
VARIABLES
.LP
A name list (as used in a command) may include names starting with '\fC$\fR'
which are replaced by the values of the conrresponding (environment) variables.
Each variable is a list of names, and the substitution preserves the name
boundaries. Variable values are never parsed as control structures and
are expanded just once, as part of a name list.
.LP
Within a name, the characters '\fC=$\fR' are not special and are considered
part of the name, but the '\fC=\fR' character is still considered the assignment
operator within the first name of each line. This produces the desired
results in most cases and avoids the need to quote the '\fC=\fR' character
in predicates and command arguments.
.LP
A variable may be assigned a value using
.LP
\fC
.DS L

    name=value
    
.DE
\fR
.LP
or
.LP
\fC
.DS L

    var←name
    
.DE
\fR
.LP
where\fI value\fR is, in general, a list of names. For example:
.LP
\fC
.DS L

    name = (a b c)
    
.DE
\fR
.LP
The syntax '\fC$name\fR' expands to the series of names in the value of
the variable. The number of elements is retrieved using '\fC$#name\fR'.
The syntax '\fC$^name\fR' can be used to expand the value of the variable
to a single name (with words joined by single spaces). Each element in
the list can be retrieved using '\fC$name[0]\fR', '\fC$name[1]\fR', etc.
The index can be a variable, as in '\fC$name[$idx]\fR', but using '\fC$$name\fR'
is a syntax error. The assignment
.LP
\fC
.DS L

    name[n]= value
    
.DE
\fR
.LP
updates the value of that position in the variable. Even if\fI value\fR
is a list, the variable still retains the same number of elements. One
of the examples further illustrates this.
.LP
Variables can be also maps, defined as in
.LP
\fC
.DS L

    name=([key1 values...] [key2 values...] ...)
    
.DE
\fR
.LP
The expression '\fC$name\fR' expands to the set of keys for the map. The
expression '\fC$name[key]\fR' expands to the values for that key. See the
example section.
.LP
Lists can be concatenated using the '\fC^\fR' operator. If both arguments
have the same number of elements, the result is a list with the same number
of elements and each one is the concatenation of the same element in both
lists. If one of the lists has one element, that element is concatenated
to each one of the elements of the other argument. Otherwise, it is an
error to try to concatenate the lists. But you might use:
.LP
\fC
.DS L

    x=($y and other values)
    
.DE
\fR
.LP
.LP
\fC
.LP
The\fR shift\fC builtin drops the first name in the named variable, or
in\fR argv\fC if no variable name is given.
.LP
The following variables are pre-defined or used by the shell:\fR argv\fC
the argument list of scripts and functions\fR argv0\fC the name of the
script\fR sts\fC the exit status of the last command. For blocks, the one
of their last command\fR path\fC the preferred locations to search for
external commands. The user may assign values to them.
.LP
Although not predefined, the\fR NS\fC variable contains the textual representation
of the name space, as shown in [cite: intro(1)], when name spaces are used.
.LP
.SH
REDIRECTIONS
.LP
Optional edirections can be written at the end of commands. Note that a
'\fR<\fC' at the start of a command line is a source command and not a
redirection.
.LP
To redirect standard input from a file, use
.LP
.DS L

    cmd... < name
    
.DE
.LP
or
.LP
.DS L

    cmd... <[in] name
    
.DE
.LP
The name in brackets indicates the channel that is to be defined as the
input channel from the named file. Here, _name_ is the name for a file
(tree), including both a path and a predicate, thus
.LP
.DS L

    cat <,-
    
.DE
.LP
would print the contents of all the regular files under the current directory.
In this example the name has an implicit '\fR.\fC' as the path and a '\fR-\fC',
which is actually '\fRtype=-\fC', as the predicate; together it means all
the regular files under the current directory). All those files are streamed
through the _in_ channel for the command.
.LP
To redirect standard output to a file, use
.LP
.DS L

    > file
    
.DE
.LP
to create the output file (or truncate it). Or use
.LP
.DS L

    >> file
    
.DE
.LP
to append to that file. In this case, for safety, no predicates are accepted;
only a file path.
.LP
Output channel names may be given after the redirection operator to redirect
output for those channels to the named file, as in:
.LP
.DS L

    cmd >[err]/tmp/errors
    cmd >[out,err]/tmp/outputanderrors
    
.DE
.LP
.LP
The syntax
.LP
.DS L

    cmd >[out:err]
    
.DE
.LP
makes the _out_ channel be that used as the _err_ channel. It is a _dup_,
and channels are named in the same order used in the assignment, as a remainder
of which channel is the old one and which one is the new one.
.LP
The syntax
.LP
.DS L

    cmd <{cmd2...}
    
.DE
.LP
Takes the output from _cmd2_ and interpolates it in the command line at
that place. This is command substitution. Each message printed by _cmd2_
is used as a different word in the command line. There are examples later,
but these are usual usages:
.LP
.DS L

    cmd <{cmd2... | lines}
    cmd <{cmd2... | words}
    cmd <{cmd2... | all}
    
.DE
.LP
.LP
The syntax
.LP
.DS L

    cmd <[in2]{cmd2...}
    
.DE
.LP
creates the _in2_ channel for _cmd_ as an input channel that will convey
the output for the enclosed _cmd2_, and the whole construct is replaced
by the name of the channel. When Clive commands convert the arguments to
input channels, they notice that the name is for an input channel and retrieve
input from there. The general construct is '\fR<[in:out1,out2...]{...}\fC'
to pipe arbitrary channels.
.LP
The syntax
.LP
.DS L

    cmd >[out2]{cmd2...}
    
.DE
.LP
is similar, but it creates an output channel to _cmd2_ given as an argument
to _cmd_.
.LP
.SH
BUILT-IN COMMANDS
.LP
The following commands are built into\fR ql\fC:\fR cd [name]\fC Change
current directory to the given one or the home directory if none.\fR pwd\fC
Print the working directory.\fR exit [sts]\fC Terminate the execution of\fR
ql\fC using the given argument, if any, as the exit status.\fR break\fC
Stop the enclosing construct (a\fR for\fC,\fR while\fC, or\fR cond\fC)
and continue executing the next command.\fR wait {tag}\fC Wait for previous
background commands to complete. If no tag is supplied, it waits for all
of them. Otherwise, it waits for the pipeline with the given tag (an optional
name written after the\fR &\fC in the pipeline).\fR type {name}\fC inform
of the type of object known as\fR name\fC. It may be a builtin, a function,
an environment variable or the path used to execute it as a command.\fR
fork {resource}\fC dups the resource, which can be\fR ns\fC,\fR io\fC,\fR
dot\fC, or\fR env\fC.\fR shift [var]\fC Drop the first element of the given
variable (\fRargv\fC by default).
.LP
Most other Clive commands are usually linked into the same\fR ql\fC binary,
use\fR type\fC to discover which ones are external and which ones are not.
.LP
.SH
EXAMPLES
.LP
Variables as lists:
.LP
.DS L

    > x=(a b c)
    > x[0]=(q w e)
    > echo $x
    q w e b c
    > echo $#x
    3
    > echo $x[0]
    q w e
    > x=<{eco $x}
    > echo $x
    q w e b c
    > echo $#x
    1
    > x=<{eco $x|words}
    > echo $#x
    5
    
.DE
.LP
Concatenation:
.LP
.DS L

    > x=(a b)
    > echo $x^x
    ax bx
    > y=($x c d)
    > echo $y
    a b c d
    > echo $#y
    4
    
.DE
.LP
Variables as maps:
.LP
.DS L

    > x=([a b] [x y z])
    > echo $x
    a x
    > y=$x[x]
    > echo $y
    y z
    > echo $#y
    2
    
.DE
.LP
.LP
Command substitution:
.LP
.DS L

    > for x <{eco a ; eco b} {
    > eco -u $x
    > }
    a
    b
    > for x <{eco a b} {
    > eco -u $x
    > }
    a b
    
.DE
Also,
.DS L

    > for line <{lf -g ,- | lines} {
    > do something to $line
    > }
    
.DE
which can be done also as:
.DS L

    > lf -g ,- | lines | for line {
    > do something to $line
    > }
    
.DE
.LP
.DS L

    > eco -u <[in2]{eco a}
    |<in2
    
.DE
.DS L

    > pf <[in2]{eco a} <[in3]{eco b c}
    c ---------      0 |<in2
    a
    c ---------      0 |<in3
    b c
    
.DE
.LP
.LP
Predicates and redirections:
.LP
Issue an error to standard error:
.DS L

    eco errors >[out:err]
    
.DE
.LP
Show all Go sources under the current directory
.DS L

    pf <,~*.go
    
.DE
Or
.DS L

    lf -g .,name~*.go | pf
    
.DE
List all regular files under the current directory:
.DS L

    lf -u ,-
    
.DE
.LP
Long-list them:
.DS L

    lf -u ,- |pf -l
    
.DE
.LP
Grep them for\fR foo\fC:
.DS L

    gr -u foo <,-
    
.DE
.LP
Define a long-list function:
.DS L

    func ll {
        lf $argv | pf -l
    }
    
.DE
.LP
.LP
.SH
SOURCE
.LP
.IP \(bu
.LP
\fR/zx/sys/src/clive/cmd/ql\fC
.LP
.SH
SEE ALSO
.LP
.IP \(bu
.LP
\fR/zx/sys/src/clive/cmd/ql/example\fC contains examples for all the syntax
understood by the shell.
.LP
.LP
.br
\l'5i'
.br
.LP
\fB User's manual.\fC\fB Section 1.\fC\fR Copyright © LSUB 2014-2016
.br
.br

